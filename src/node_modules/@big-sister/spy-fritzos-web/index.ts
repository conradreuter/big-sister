import { Identifier, Presence, SpyPlugin } from '@big-sister'
import createLogger from '@big-sister/logging'
import * as crypto from 'crypto'
import * as request from 'request-promise-native'
import { Observable } from 'rxjs'
import { Parser as XmlParser } from 'xml2js'

const log = createLogger('spy-fritzos-web')

const DEFAULT_INTERVAL = 30000

const xmlParser = new XmlParser()

/**
 * Provides presence information via the Fritz!OS web interface.
 */
const plugin: SpyPlugin<Options> = async (options) => {
  const {
    interval = DEFAULT_INTERVAL,
    password,
    router,
    username,
  } = options
  const sessionId = await log.failOnError(authenticate())
  return {
    presence$: log.failOnError(
      Observable
        .defer(fetchPresence) // fetch initially...
        .expand(() => (
          Observable
            .timer(interval)
            .concatMap(fetchPresence) // ...and then every {interval}ms
        ))
    )
  }

  async function authenticate(): Promise<string> {
    log.info(`Authenticating against ${router}`)
    const challengeXml = await request.get(`http://${router}/login_sid.lua`)
    const {
      SessionInfo: {
        BlockTime: [blockTime],
        Challenge: [challenge],
      },
    } = await parseXml(challengeXml)
    if (parseInt(blockTime) > 0) {
      throw new Error(`Authentication blocked for ${blockTime} seconds`)
    }
    // see https://avm.de/fileadmin/user_upload/Global/Service/Schnittstellen/AVM_Technical_Note_-_Session_ID.pdf
    const response = challenge + '-' + md5(challenge + '-' + password)
    const sessionIdXml = await request.get(`http://${router}/login_sid.lua?username=${username}&response=${response}`)
    const {
      SessionInfo: {
        BlockTime: [newBlockTime],
        SID: [sessionId],
      },
    } = await parseXml(sessionIdXml)
    if (sessionId === '0000000000000000') {
      throw new Error(`Authentication failed (blocked for ${newBlockTime} seconds)`)
    }
    return sessionId
  }

  function md5(input: string): string {
    const hash = crypto.createHash('md5')
    hash.update(new Buffer(input, 'ucs-2'))
    return hash.digest('hex')
  }

  function parseXml(xml: string): Promise<any> {
    return new Promise((resolve, reject) => {
      xmlParser.parseString(xml, (err: any, result: any) => err ? reject(err) : resolve(result))
    })
  }

  function fetchPresence(): Promise<Presence> {
    return log.measure(`Fetching presence from ${router}`, async () => {
      const timestamp = new Date()
      const { data: { active: devices } } = await request.post(
        `http://${router}/data.lua`,
        { form: { sid: sessionId, page: 'netDev', type: 'all' }, json: true },
      )
      const presentIdentifiers = devices.map((device: any) => device.mac.toLowerCase() as Identifier)
      log.verbose(`New presence:`)
      for (const identifier of presentIdentifiers) log.verbose(`'${identifier}' is present`)
      return { presentIdentifiers, timestamp }
    })
  }
}

export default plugin

interface Options {

  /**
   * The interval (in milliseconds) in which new presence information is read.
   *
   * Defaults to 30000.
   */
  interval?: number

  /**
   * The password used for authenticating against the router.
   */
  password: string

  /**
   * The IP address of the router.
   */
  router: string

  /**
   * The user name used for authenticating against the router.
   */
  username: string
}
