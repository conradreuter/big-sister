import { Observable } from 'rxjs'
import * as winston from 'winston'

const LOG_LEVEL_MAP = {
  verbose: 'verbose',
  info: 'info',
  warn: 'warn',
  error: 'error'
}
export const LOG_LEVELS = Object.keys(LOG_LEVEL_MAP)

let logLevel: typeof LOG_LEVEL_MAP[LogLevel] = 'warn'

export function setLogLevel(newLogLevel: LogLevel) {
  logLevel = LOG_LEVEL_MAP[newLogLevel]
  for (const logger of Object.values(winston.loggers.loggers)) {
    logger.level = logLevel
  }
}

export default function createLogger(packageName: string): Logger {
  const log = winston.loggers.get(packageName, {
    console: {
      colorize: true,
      label: packageName,
    },
  })
  log.level = logLevel
  return Object.assign(log, { failOnError, fatal, measure })

  function failOnError(value: any): any {
    switch (true) {
      case typeof value === 'function':
        return (...args: any[]) => {
          try {
            return value(...args)
          } catch (err) {
            fatal(err)
          }
        }
      case value instanceof Observable:
        return value.catch((err: any) => (fatal(err), Observable.empty()))
      case value instanceof Promise:
        return value.catch(fatal)
    }
    return
  }

  function fatal(msg: string) {
    log.error(msg)
    throw new FatalError(msg)
  }

  function measure<T>(description: string, fn: () => T): T {
    log.verbose(`${description}...`)
    const start = hrtimeMilliseconds()
    const result = fn()
    if (result instanceof Promise) {
      return result.then((result2) => {
        end()
        return result2
      }) as any // T === Promise<U>
    } else {
      end()
      return result
    }

    function end(): any {
      const time = hrtimeMilliseconds() - start
      log.verbose(`${description} took ${time.toFixed(3)}ms`)
    }
  }
}

function hrtimeMilliseconds(): number {
  const [seconds, nanoseconds] = process.hrtime()
  return seconds * 1e3 + nanoseconds / 1e6
}

export class FatalError extends Error {
  constructor(msg: string) {
    super(`Fatal error: ${msg}`)
    Object.setPrototypeOf(this, FatalError.prototype)
  }
}

type Logger = { [logLevel in LogLevel]: LoggingMethod } & {
  failOnError: (
    & (<T extends Function>(fn: T) => T)
    & (<T>(promise: Promise<T>) => Promise<T>)
    & (<T>(observable: Observable<T>) => Observable<T>)
  )
  fatal: LoggingMethod,
  measure: <T>(description: string, fn: () => T) => T,
}
type LoggingMethod = (msg: string) => void
export type LogLevel = keyof typeof LOG_LEVEL_MAP
