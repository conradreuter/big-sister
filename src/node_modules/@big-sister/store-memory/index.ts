import { Identifier, Interval, PastPresence, StorePlugin } from '@big-sister'
import createLogger from '@big-sister/logging'

const log = createLogger('store-memory')

/**
 * Stores presence information in memory for testing purposes.
 */
const plugin: StorePlugin<{}> = async (options) => {
  log.warn('Do not use the in-memory store in production!')
  const cache = new Map<Identifier, Interval[]>()
  const keyValueStore = new Map<string, any>()
  return {
    becomePresent,
    stayPresent,
    becomeAbsent,
    readPastPresences,
    readKeyValuePair,
    writeKeyValuePair,
  }

  async function becomePresent(identifier: Identifier, timestamp: Date): Promise<void> {
    let intervals = cache.get(identifier)
    if (!intervals) cache.set(identifier, intervals = [])
    intervals.unshift({ from: timestamp, to: timestamp })
  }

  async function stayPresent(identifier: Identifier, timestamp: Date): Promise<void> {
    const intervals = cache.get(identifier)!
    intervals[0].to = timestamp
  }

  async function becomeAbsent(identifier: Identifier, timestamp: Date): Promise<void> {
  }

  async function readPastPresences(timeframe: Interval): Promise<PastPresence[]> {
    const pastPresences: PastPresence[] = []
    for (const [identifier, allIntervals] of cache) {
      const intervals = allIntervals.filter(overlapsTimeframe)
      if (!intervals.length) continue
      pastPresences.push({ identifier, intervals })
    }
    return pastPresences

    function overlapsTimeframe(interval: Interval): boolean {
      return interval.from <= timeframe.to && timeframe.from <= interval.to
    }
  }

  async function readKeyValuePair<T>(key: string): Promise<T> {
    return keyValueStore.get(key)
  }

  async function writeKeyValuePair<T>(key: string, value: T): Promise<void> {
    keyValueStore.set(key, value)
  }
}

export default plugin

