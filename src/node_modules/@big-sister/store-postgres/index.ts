import { Identifier, Interval, PastPresence, StorePlugin } from '@big-sister'
import createLogger from '@big-sister/logging'
import * as Postgres from 'pg-promise'

const log = createLogger('store-postgres')

/**
 * Stores presence information via Postgres.
 */
const plugin: StorePlugin<{}> = async (options) => {
  const database = Postgres()(options)
  const rowIds = new Map<Identifier, number>()
  await setupDatabase()
  return {
    becomePresent,
    stayPresent,
    becomeAbsent,
    readKnownIdentifiers,
    readPastPresences,
    readKeyValuePair,
    writeKeyValuePair,
  }

  async function setupDatabase(): Promise<void> {
    log.info('Setting up database')
    await log.failOnError(database.none(`
      CREATE TABLE IF NOT EXISTS presence_intervals
      (
        row_id SERIAL PRIMARY KEY NOT NULL,
        identifier VARCHAR(128) NOT NULL,
        interval_from TIMESTAMP NOT NULL,
        interval_to TIMESTAMP NOT NULL
      );

      CREATE TABLE IF NOT EXISTS key_value_pairs
      (
        key VARCHAR(128) PRIMARY KEY NOT NULL,
        value JSONB
      );
    `))
  }

  async function becomePresent(identifier: Identifier, timestamp: Date): Promise<void> {
    log.verbose(`Inserting new presence interval for '${identifier}'`)
    const result = await log.failOnError(database.one(
      `
        INSERT INTO presence_intervals(identifier, interval_from, interval_to)
        VALUES($<identifier>, $<from>, $<to>)
        RETURNING row_id
      `,
      {
        identifier,
        from: timestamp,
        to: timestamp,
      },
    ))
    const { row_id: rowId } = result
    log.verbose(`'${identifier}' has now row id ${rowId}`)
    rowIds.set(identifier, rowId)
  }

  async function stayPresent(identifier: Identifier, timestamp: Date): Promise<void> {
    const rowId = rowIds.get(identifier)
    log.verbose(`Updating presence interval for '${identifier}' with row id ${rowId}`)
    await log.failOnError(database.none(
      `
        UPDATE presence_intervals
        SET interval_to = $<to>
        WHERE row_id = $<rowId>
      `,
      {
        rowId,
        to: timestamp,
      },
    ))
  }

  async function becomeAbsent(identifier: Identifier, timestamp: Date): Promise<void> {
    log.verbose(`Forgetting row id for '${identifier}'`)
    rowIds.delete(identifier)
  }

  async function readKnownIdentifiers(): Promise<Identifier[]> {
    log.verbose('Reading known identifiers')
    const results = await log.failOnError(database.manyOrNone(
      `
        SELECT DISTINCT identifier
        FROM presence_intervals
        ORDER BY identifier
      `
    ))
    return results.map(result => result.identifier)
  }

  async function readPastPresences(timeframe: Interval): Promise<PastPresence[]> {
    log.verbose(`Reading stored presence between ${timeframe.from} and ${timeframe.to}`)
    const results = await log.failOnError(database.manyOrNone(
      `
        SELECT identifier, interval_from, interval_to
        FROM presence_intervals
        WHERE interval_from <= $<to> AND $<from> <= interval_to
        ORDER BY interval_from ASX
      `,
      {
        ...timeframe,
      }
    ))
    const pastPresences: { [identifier: string]: PastPresence } = {}
    for (const { identifier, interval_from: from, interval_to: to } of results) {
      const presence = pastPresences[identifier] || (
        pastPresences[identifier] = { identifier, intervals: [] }
      )
      presence.intervals.push({ from, to })
    }
    return Object.values(pastPresences)
  }

  async function readKeyValuePair<T>(key: string): Promise<T> {
    log.verbose(`Reading value for key '${key}'`)
    const result = await log.failOnError(database.oneOrNone(
      `
        SELECT value
        FROM key_value_pairs
        WHERE key = $<key>
      `,
      {
        key,
      },
    ))
    return result ? result.value : undefined
  }

  async function writeKeyValuePair<T>(key: string, value: T): Promise<void> {
    log.verbose(`Setting value for key '${key}'`)
    if (value === null || value === undefined) {
      await log.failOnError(database.none(
        `
          DELETE FROM key_value_pairs
          WHERE key = $<key>
        `,
        {
          key,
        }
      ))
    } else {
      await log.failOnError(database.none(
        `
          INSERT INTO key_value_pairs(key, value)
          VALUES($<key>, $<value>)
          ON CONFLICT (key)
          DO UPDATE SET value = $<value>
        `,
        {
          key,
          value,
        },
      ))
    }
  }
}

export default plugin
